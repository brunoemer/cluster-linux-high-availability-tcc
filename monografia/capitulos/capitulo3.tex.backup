\chapter{Virtualização}
\label{cap:virtualizacao}

O conceito virtualização surgiu na década de 60, onde muitas vezes era necessário que um usuário utilizasse um ambiente individual, 
com suas próprias aplicações e totalmente isolado dos demais usuários. Esse foi um dos principais motivos para a criação de máquinas 
virtuais, mais conhecida como \ac{VM}, que apresentaram uma forte expansão com o sistema operacional \textit{370} que foi desenvolvido 
pela \textit{IBM} e foi um dos principais sistemas comerciais com suporte a virtualização da época. Esse sistema operacional executava 
sobre \textit{mainframes}, que na época eram grandes servidores capazes de processar um grande volume de informações \cite{laureano2008}. 

Na década de 80, houve uma redução da utilização da virtualização devido a popularização do \ac{PC}. Na época era mais vantajoso disponibilizar 
um \ac{PC} para cada usuário, do que investir em \textit{mainframes}. Devido ao crescente avanço e o melhor desempenho do \ac{PC} e
ao surgimento da linguagem \textit{Java}, no início da década de 90, a tecnologia de virtualização retornou com o conceito de virtualização
de aplicação.

A virtualização foi definida nos anos 60 e 70 como uma camada entre o \textit{hardware} e o sistema operacional que possibilitava a 
divisão e proteção dos recursos físicos. Porém, atualmente ela abrange outros conceitos, como por exemplo a \ac{JVM}, que não virtualiza
necessariamente um \textit{hardware}. Ela proporciona que uma aplicação convidada execute em diferentes tipos de sistemas operacionais.

Atualmente define-se virtualização como uma camada de \textit{software} que utiliza os serviços fornecidos de uma determinada interface de 
sistema para criar outra interface de mesmo nível. Essa camada irá permitir a comunicação entre interfaces distintas, de forma que uma 
aplicação desenvolvida para uma plataforma \textit{X} possa também executar em uma plataforma \textit{Y} \cite{laureano2008}.

Nesse Capítulo será apresentado as diferentes classificações de máquinas virtuais, porém antes disso deve-se conhecer os diferentes 
tipos de interfaces existentes em sistemas de computação:
\begin{itemize}
 \item Conjunto de instruções ou \ac{ISA}: é a interface básica, que fica entre o \textit{software} e o \textit{hardware}, e é composta por 
 instruções de código de máquina. Esta interface é dividida em dois grupos:
 \begin{itemize}
  \item Instruções de usuário ou \textit{User \ac{ISA}}: são instruções de \textit{hardware} disponíveis à aplicações de usuários. Essas 
  executam em modo não-privilegiado. Um exemplo de instrução de usuário é uma instrução do processador executadas diretamente sobre a memória
  alocada para o programa ????;
  \item Instruções de sistema ou \textit{System \ac{ISA}}: são instruções exclusivamente acessíveis ao núcleo do sistema operacional. 
  Essas são executadas em modo privilegiado. Pode-se citar as instruções de entrada e saída (\textit{E/S}) como exemplo de instruções de sistema;
 \end{itemize}
 \item Chamadas de sistema ou \textit{syscalls}: são operações oferecidas pelo núcleo do sistema operacional para as aplicações dos usuários.
 Essas operações permitem o acesso controlado aos dispositivos, memória e processador. Um exemplo de chamada de sistema é uma escrita em disco.
\end{itemize}

Máquinas virtuais podem ser divididas em dois grupos principais, que são: as máquinas virtuais de aplicação, na (Seção \ref{section:virtaplicacao}), 
e máquinas virtuais de sistema, na (Seção \ref{section:virtsistema}). As máquinas virtuais de aplicação fazem a virtualização de uma 
aplicação e suportam apenas um processo ou aplicação. Um exemplo de máquina virtual de aplicação é a \ac{JVM}. Já uma máquina virtual de 
sistema suporta sistemas operacionais convidados, com suas aplicações executando sobre ele (Figura \ref{fig:vms_tipos}). Uma máquina virtual 
executando com \ac{KVM} é um exemplo de máquina virtual de aplicação \cite{laureano2008}.

\begin{figure}[vms_tipos]
 \centering
 \includegraphics[width=380px]{img/vms_tipos.eps}
 \caption{Máquinas virtuais de aplicação e de sistema.}
 \label{fig:vms_tipos}
 Fonte: \citet{laureano2008}
\end{figure}

\section{Máquinas virtuais de aplicação}
\label{section:virtaplicacao}

As máquinas virtuais de aplicação, também chamadas de máquinas virtuais de processos são responsáveis por prover um ambiente
onde um sistema operacional suporte uma aplicação convidada, sendo que esta aplicação possui um conjunto de instruções ou de chamadas
do sistema diferentes da arquitetura do sistema hospedeiro. De fato quando temos chamadas do sistema operacional ou instruções de máquina 
que são diferentes das oferecidas pela máquina real, será necessário uma tradução dessas interfaces que será feita pela camada  de 
virtualização. Abaixo são detalhados dois tipos de máquinas virtuais de aplicação:

\begin{itemize}
 \item Máquinas virtuais de linguagem de alto nível: esse tipo de máquina virtual foi criado levando em consideração uma linguagem de 
 programação e seu compilador. O código compilado gera um código binário que não pode ser executado em uma arquitetura real, mas pode
 ser executada em uma máquina virtual. Sendo assim para cada arquitetura ou sistema operacional deve existir uma máquina virtual que
 permita a execução da aplicação nesse ambiente. Como exemplo deste tipo de máquina virtual pode-se citar a: \textit{Microsoft Common 
 Language Infrastructure}, base do \textit{.Net} e a máquina virtual Java (\ac{JVM}) \cite{carissimi2008};
 \item Emulação no sistema operacional: nesse caos é feito um mapeamento entre as chamadas de sistema que são utilizadas pela aplicação 
 e as chamadas do sistema operacional real. A virtualização de aplicação pode ser encontrado em ferramentas que emulam uma aplicação 
 desenvolvida para uma plataforma em outra plataforma distinta, como por exemplo o \textit{Wine}, que permite executar aplicações 
 \textit{Windows} em plataformas \textit{Linux}.
\end{itemize}

%Na virtualização de aplicação também existem máquinas virtuais que utilizam as mesmas interfaces \ac{ISA} do computador real,
%com isso uma grande parte das instruções podem ser executadas diretamente, com exceção de instruções privilegiadas, que serão devidamente
%tratadas. Alguns tipos de máquinas virtuais de aplicação que utilizam as interfaces do sistema real são:

%\begin{itemize}
% \item Sistemas operacionais multi-tarefas: sistemas operacionais que suportam simultaneamente mais de um usuário também podem ser
% vistos como máquinas virtuais. Em um sistema multi-tarefa cada processo possui um ``processador virtual'' (devido a rápida troca de 
% contextos do processador real), uma ``memória virtual'' (memória alocada para o processo) e outros recursos que podem ser acessados
% através de chamadas de sistema;
% \item Tradutores dinâmicos: esses tradutores analisam e otimizam o código de máquina para torná-lo mais eficiente. Essa otimização 
% pode ser feita durante a carga do processo na memória ou durante a execução das instruções. Pode-se citar como exemplo o \ac{JIT} 
% \textit{Bytecode compiler};
% \item Depuradores de memória: são sistemas de depuração de memória que detectam erros decorrentes do uso incorreto da memória.
% Um exemplo de depurador é o sistema \textit{Valgrind}, que utiliza uma máquina virtual para efetuar essa depuração.
%\end{itemize}

\section{Máquinas virtuais de sistema}
\label{section:virtsistema}

As máquinas virtuais de sistema também chamadas de hipervisor ou \ac{VMM}, são uma camada de \textit{software} que possibilita
que um ou mais sistemas operacionais convidados executem independentemente sobre um memsmo computador físico. O hipervisor prove uma interface
\ac{ISA} virtual que pode ou não ser igual a interface real, e virtualiza outros componentes de \textit{hardware}, para que cada máquina
virtual convidada possa ter seus próprios recursos isolados.

Nesse modelo, um ambiente de virtualização de sistema é composto basicamente por três componentes:
\begin{itemize}
 \item Sistema real: também pode ser chamado de hospedeiro, que é o \textit{hardware} onde o sistema de virtualização irá executar;
 \item Camada de virtualização: é conhecida como hipervisor ou também chamado de \ac{VMM} e tem como função criar interfaces virtuais a
 partir de interfaces físicas, para a comunicação do sistema virtual com o sistema real;
 \item Sistema virtual: também conhecido como \textit{guest}, ou sistema convidado, que executa sobre o sistema real. Geralmente
 existem vários sistemas virtuais executando simultaneamente sobre o sistema real.
\end{itemize}

Virtualização de sistema utiliza abstração em sua arquitetura, por exemplo, ela transforma um disco rígidos físico em dois discos rígidos
virtuais menores, sendo que esses discos virtuais são arquivos armazenados no disco físico. Sabendo que arquivos são uma abstração
em um disco rígidos físico, pode-se dizer que virtualização não é apenas uma camada de abstração do \textit{hardware}, ela faz a reprodução 
do \textit{hardware} \cite{smithenair2005}.

Existem basicamente duas arquiteturas de hipervisor de sistema, apresentados na Figura \ref{fig:vms_arquiteturas} e detalhados
abaixo \cite{maziero2013}:
\begin{itemize}
 \item Hipervisores nativos: esse hipervisor executa diretamente sobre o \textit{hardware}, ou seja, sem um sistema operacional
 hospedeiro. O hipervisor nativo faz a multiplexação dos recursos do \textit{hardware} como memória, disco rígido, interface de rede, 
 entre outros, e diponibiliza esses recursos para as máquinas virtuais. Alguns exemplos que utilizam esse hipervisor são 
 \textit{IBM 370}, o \textit{Xen} e o \textit{VMware ESX Server};
 \item Hipervisores convidados: esse tipo de hipervisor executa sobre um sistema operacional hospedeiro, e utiliza os recursos 
 desse sistema para gerar recursos virtuais para as máquinas virtuais. Normalmente esse tipo suporta apenas um sistema 
 operacional convidado para cada hipervisor. Exemplos deste tipo de sistema são: o \textit{VirtualBox} e o \textit{QEmu}.
\end{itemize}

Sabendo essas definições das arquiteturas pode-se concluir que hipervisor convidados são mais flexíveis que os nativos, pois podem ser 
implementados em diversos sistemas operacionais e \textit{hardwares}. Já o hipervisor nativo possui melhor desempenho pois acessa o 
\textit{hardware} diretamente.

\begin{figure}[vms_arquiteturas]
 \centering
 \includegraphics[width=380px]{img/vms_arquiteturas.eps}
 \caption{Arquiteturas de máquinas virtuais de sistema.}
 \label{fig:vms_arquiteturas}
 Fonte: \citet{maziero2013}
\end{figure}

%\subsection{Níveis de virtualização}
%\label{section:virtniv}
%\begin{itemize}
% \item Virtualização de recursos: neste tipo de virtualização os recursos como memória e disco, além das instruções 
% privilegiadas (\textit{system \ac{ISA}}) são virtualizadas. Somente a interface \ac{ISA} de usuário é utilizada diretamente, 
% por isso o desempenho do sistema convidado é mais próximo a um sistema executando diretamente sobre um \textit{hardware}. O 
% \textit{VirtualBox} e o \textit{VirtualPC da Microsoft} são exemplos de virtualização de recursos;
% \item Virtualização completa: na virtualização completa todas interfaces são virtualizadas. Sendo assim o hipervisor fornece uma
% interface distinta ao sistema operacional convidado. Esse tipo de virtualização possui um eficiência menor, por outro lado ele
% permite executar sistemas operacionais em plataformas distintas a qual foram projetadas inicialmente. Por exemplo, o 
% \textit{MS Virtual PC for MAC}, que permite executar o sistema \textit{Windows} sobre plataforma de \textit{hardware} \textit{PowerPC}.
%\end{itemize}

%Tendo essas classificações, pode-se combiná-las para se obter quatro maneiras diferentes de implementar virtualização. Na Figura 
%\ref{fig:vms_classificacao} tem-se essas combinações com seus respectivos exemplos.

%\begin{figure}[vms_classificacao]
% \centering
% \includegraphics[width=400px]{img/vms_classificacao.eps}
% \caption{Classificação de máquinas virtuais de sistema.}
% \label{fig:vms_classificacao}
% Fonte: \citet{laureano2008}
%\end{figure}

\subsection{Estratégias de virtualização}
\label{section:virtestrat}

As máquinas virtuais de sistema podem ser classificadas em diferentes tipos de estratégias. Atualmente as estratégias mais utilizadas
são a virtualização total e a paravirtualização. Antes disso deve-se compreender uma técnica conhecida como tradução dinâmica. Nesta 
técnica o hipervisor adapta as instruções geradas pelo sistema convidado para a interface \ac{ISA} do sistema real. Outra função da 
tradução dinâmica é analisar e reoganizar as instruções do sistema convidado, com o objetivo de melhorar o desempenho da execução do 
sistema convidado.

\begin{itemize}
 \item Virtualização total: nesta estratégia todas as interfaces de acesso ao \textit{hardware} são virtualizadas. Desta forma
 possibilita-se que sistemas operacionais convidados executem como se estivessem diretamente sobre o \textit{hardware}. Na virtualização
 total o conjunto de instruções do processador é acessível somente pelo hipervisor, sendo que essa estratégia utiliza tradução dinâmica
 para traduzir as instruções do sistema convidado. A grande vantagem dessa virtualização é a possibilidade de um sistema convidado 
 executar sem a necessidade de ser modificado. Porém, existe uma redução significativa no desempenho devido ao hipervisor intermediar 
 todas as chamada de sistemas e operações do sistema convidado. Um exemplo de virtualização total é o \textit{QEmu};
 \item Paravirtualização: esta utiliza arquitetura de hipervisor nativo, prove um melhor acoplamento entre os sistemas operacionais 
 convidados e o hipervisor. Para isso o sistema convidado deve ser adaptado para o hipervisor no qual executará, ou seja, a interface de 
 sistema (\textit{system ISA}) será acessada diretamente pelo sistema convidado, resultando em um desempenho melhor. São exemplos de 
 sistema que implementa a paravirtualização: o \textit{Xen} e o \textit{VMware ESX Server}.
\end{itemize}

A paravirtualização possui um desempenho melhor se comparada a virtualização total, pois acessa alguns recursos diretamente, sendo que 
o hipervisor é reponsável somente por impedir que o sistema convidado faça operações indevidas. Por exemplo, o gerenciamento da memória, 
na virtualização total o hipervisor reserva um espaço para cada sistema convidado, que por sua vez acessa a memória como se fosse a memória 
de uma máquina física iniciando seu endereçamento em zero. Sendo assim cada vez que o sistema convidado acessar a memória, o hipervisor 
precisará converter os endereços do sistema convidado para endereços reais. Na paravirtualização o hipervisor informa ao sistema 
convidado a área de memória que ele pode utilizar, otimizando assim as operações.

Por outro lado, a virtualização total possui maior portabilidade, ou seja, permite que sistemas operacionais convencionais executem
como convidados, sem serem modificados. Pode-se, por exemplo, transferir um sistema operacional instalado diretamente em uma máquina física para um ambiente
virtual, sem a necessidade de reinstalar e reconfigurar o sistema operacional.

A virtualização total obteve uma grande ganho de performance com a incorporação da virtualização aos processadores, através das 
tecnologias \ac{IVT} da \textit{Intel} e \ac{AMD-V} da \textit{AMD}. Elas possuem dois modos, um para execuções normais e para hipervisor, 
e outro específico para máquinas virtuais. 

\subsection{Vantagens}
\label{section:virtvantag}

Em muitos casos empresas utilizam serviços distribuídos entre servidores físicos, como, por exemplo, servidores de e-mail, hospedagens e 
banco de dados, com isso existe uma ociosidade grande de recursos. Portanto uma das grandes vantagens da virtualização de sistema é um melhor 
aproveitamento destes recursos, alocando vários serviços em um único servidor físico e assim gerando um melhor aproveitamento do \textit{hardware} 
\cite{moreira2006}. Além disso, pode-se ter uma redução de custos com a administração e a manutenção dos servidores. Em um ambiente 
heterogênio pode-se também utilizar virtualização, pois ela permite a instalação de diversos sistemas operacionais em um único servidor.
Considerando isto, esse tipo de virtualização favorece a implementação do conceito um servidor por serviço, que consiste em ter um servidor
para cada serviço. Outro fator relevante que favorece a implementação desse conceito é se caso exista uma falha de segurança em um serviço \cite{carissimi2008}.

Uma outra motivação para a utilização de virtualização do sistema consiste no custo da energia elétrica. A economia de energia pode ser obtida 
através da implantação de servidores mais robustos para substituir dezenas de servidores comuns. Outros fatores como refrigeração do ambiente e 
espaço físico utilizado também podem ser reduzidos com a implantação de virtualização de servidores, e consequentemente, reduzem os 
custos de energia.


A virtualização favorece a implementação do conceito um servidor por serviço, que consiste em ter um servidor para cada serviço.
Mas porque não colocar todos serviços em um único servidor? Muitas vezes com uma variedade de serviços é necessário diferentes 
sistemas operacionais, ou os serviços necessitam rodar nas mesmas portas, portanto isto se torna inviável. Outro fator relevante que 
também favorece a implementação de um servidor por serviço é, caso exista uma falha de segurança em apenas um serviço, essa 
vulnerabilidade poderá comprometer todos os outros serviços \cite{carissimi2008}.

Virtualizacao de desktop ???

%\section{Emulação ????}

%Emulação é a capacidade de uma aplicação ou um dispositivo imitar um determinado conjunto de \textit{hardware}. Normalmente é
%executado como um aplicativo em um sistema operacional. A emulação é uma camada de \textit{software} que possibilita a execução
%de uma plataforma em outra plataforma distinta, com isso obtem-se a portabilidade das máquinas virtuais hospedeiras \cite{silva2009}.

%Este tipo de virtualização possui uma considerável redução de desempenho, pelo fato de toda comunicação com o \textit{hardware}
%ser intermediada pela camada de \textit{software} que faz a sua tradução. Por outro lado ela não visa desempenho, mas sim flexibilidade,
%por exemplo ela permite que desenvolvedores de \textit{firmware} e de \textit{hardware} simulem e validem aplicativos sem a presença
%do \textit{hardware} real.

%\begin{figure}[acoplamento_interfaces]
% \centering
% \includegraphics[height=140px]{img/acoplamento_interfaces.eps}
% \caption{Acoplamento entre interfaces distintas}
% \label{fig:acoplamento_interfaces}
% Fonte: \citet{laureano2008}
%\end{figure}
%Exemplo de camada de virtualização \ref{fig:acoplamento_interfaces} .... VER ONDE COLOCAR
